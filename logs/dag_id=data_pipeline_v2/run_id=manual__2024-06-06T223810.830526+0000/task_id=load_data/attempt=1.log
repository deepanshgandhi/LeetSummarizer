[2024-06-06T22:38:14.751+0000] {local_task_job_runner.py:120} INFO - ::group::Pre task execution logs
[2024-06-06T22:38:14.790+0000] {taskinstance.py:2076} INFO - Dependencies all met for dep_context=non-requeueable deps ti=<TaskInstance: data_pipeline_v2.load_data manual__2024-06-06T22:38:10.830526+00:00 [queued]>
[2024-06-06T22:38:14.806+0000] {taskinstance.py:2076} INFO - Dependencies all met for dep_context=requeueable deps ti=<TaskInstance: data_pipeline_v2.load_data manual__2024-06-06T22:38:10.830526+00:00 [queued]>
[2024-06-06T22:38:14.808+0000] {taskinstance.py:2306} INFO - Starting attempt 1 of 1
[2024-06-06T22:38:14.863+0000] {taskinstance.py:2330} INFO - Executing <Task(PythonOperator): load_data> on 2024-06-06 22:38:10.830526+00:00
[2024-06-06T22:38:14.884+0000] {warnings.py:110} WARNING - /home/***/.local/lib/python3.12/site-packages/***/task/task_runner/standard_task_runner.py:61: DeprecationWarning: This process (pid=145) is multi-threaded, use of fork() may lead to deadlocks in the child.
  pid = os.fork()

[2024-06-06T22:38:14.889+0000] {standard_task_runner.py:63} INFO - Started process 147 to run task
[2024-06-06T22:38:14.889+0000] {standard_task_runner.py:90} INFO - Running: ['***', 'tasks', 'run', 'data_pipeline_v2', 'load_data', 'manual__2024-06-06T22:38:10.830526+00:00', '--job-id', '57', '--raw', '--subdir', 'DAGS_FOLDER/***.py', '--cfg-path', '/tmp/tmp77b02rbd']
[2024-06-06T22:38:14.895+0000] {standard_task_runner.py:91} INFO - Job 57: Subtask load_data
[2024-06-06T22:38:14.927+0000] {warnings.py:110} WARNING - /home/***/.local/lib/python3.12/site-packages/***/settings.py:195: DeprecationWarning: The sql_alchemy_conn option in [core] has been moved to the sql_alchemy_conn option in [database] - the old setting has been used, but please update your config.
  SQL_ALCHEMY_CONN = conf.get("database", "SQL_ALCHEMY_CONN")

[2024-06-06T22:38:15.011+0000] {task_command.py:426} INFO - Running <TaskInstance: data_pipeline_v2.load_data manual__2024-06-06T22:38:10.830526+00:00 [running]> on host be153ff008c0
[2024-06-06T22:38:15.232+0000] {taskinstance.py:2648} INFO - Exporting env vars: AIRFLOW_CTX_DAG_OWNER='sanket' AIRFLOW_CTX_DAG_ID='data_pipeline_v2' AIRFLOW_CTX_TASK_ID='load_data' AIRFLOW_CTX_EXECUTION_DATE='2024-06-06T22:38:10.830526+00:00' AIRFLOW_CTX_TRY_NUMBER='1' AIRFLOW_CTX_DAG_RUN_ID='manual__2024-06-06T22:38:10.830526+00:00'
[2024-06-06T22:38:15.239+0000] {taskinstance.py:430} INFO - ::endgroup::
[2024-06-06T22:38:15.244+0000] {logging_mixin.py:188} INFO - /opt/***/dags/src/data_preprocessing/service_account_key.json
[2024-06-06T22:38:16.023+0000] {python.py:237} INFO - Done. Returned value was: [{'Plain Text': "Use hashing. Go through the list of numbers, remember each number's position in a dictionary. For each number, check if the difference between the target and the current number exists in the dictionary. If it does, we've found the pair that adds up to the target, return their indices.", 'Code': 'class Solution:\r\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\r\n        prevMap = {}  # val -> index\r\n\r\n        for i, n in enumerate(nums):\r\n            diff = target - n\r\n            if diff in prevMap:\r\n                return [prevMap[diff], i]\r\n            prevMap[n] = i', 'Question': 'Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\r\n\r\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\r\n\r\nYou can return the answer in any order.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [2,7,11,15], target = 9\r\nOutput: [0,1]\r\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].'}, {'Plain Text': '\r\nUse hashing. Go through both strings, remembering the count of each character in separate dictionaries for each string. For every character encountered in both strings, increment its count in the respective dictionaries. Once the traversal is complete, compare the dictionaries. If they are equal, it means both strings have the same characters with the same counts, indicating that one is an anagram of the other. Return true if the dictionaries are equal, otherwise return false.', 'Code': 'class Solution:\r\n    def isAnagram(self, s: str, t: str) -> bool:\r\n        if len(s) != len(t):\r\n            return False\r\n\r\n        countS, countT = {}, {}\r\n\r\n        for i in range(len(s)):\r\n            countS[s[i]] = 1 + countS.get(s[i], 0)\r\n            countT[t[i]] = 1 + countT.get(t[i], 0)\r\n        return countS == countT', 'Question': 'Given two strings s and t, return true if t is an anagram of s, and false otherwise.\r\n\r\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: s = "anagram", t = "nagaram"\r\nOutput: true'}, {'Plain Text': 'Use the two-pointer technique on a sorted list. Start with pointers at both ends of the list and adjust them based on the sum of the numbers at these pointers: move the right pointer left if the sum is too large, or the left pointer right if the sum is too small. Return the 1-based indices when the sum equals the target.', 'Code': 'class Solution:\r\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\r\n        l, r = 0, len(numbers) - 1\r\n\r\n        while l < r:\r\n            curSum = numbers[l] + numbers[r]\r\n\r\n            if curSum > target:\r\n                r -= 1\r\n            elif curSum < target:\r\n                l += 1\r\n            else:\r\n                return [l + 1, r + 1]\r\n', 'Question': 'Given an array of integers numbers that is sorted in non-decreasing order.\r\n\r\nReturn the indices (1-indexed) of two numbers, [index1, index2], such that they add up to a given target number target and index1 < index2. Note that index1 and index2 cannot be equal, therefore you may not use the same element twice.\r\n\r\nThere will always be exactly one valid solution.\r\n\r\nYour solution must use \r\nð‘‚(1)\r\nO(1) additional space.\r\n\r\nExample 1:\r\n\r\nInput: numbers = [1,2,3,4], target = 3\r\n\r\nOutput: [1,2]\r\nExplanation:\r\nThe sum of 1 and 2 is 3. Since we are assuming a 1-indexed array, index1 = 1, index2 = 2. We return [1, 2].'}, {'Plain Text': "Use hashing. Iterate through the list while storing each number's index in a dictionary. For each number, calculate the difference needed to reach the target and check if this difference is already in the dictionary. If it is, return the indices of the current number and the number that makes up the difference.", 'Code': 'class Solution:\r\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\r\n        prevMap = {}  # val -> index\r\n\r\n        for i, n in enumerate(nums):\r\n            diff = target - n\r\n            if diff in prevMap:\r\n                return [prevMap[diff], i]\r\n            prevMap[n] = i\r\n', 'Question': 'Given an array of integers nums and an integer target, return the indices i and j such that nums[i] + nums[j] == target and i != j. \r\n\r\nYou may assume that every input has exactly one pair of indices i and j that satisfy the condition.\r\n\r\nReturn the answer with the smaller index first.\r\n\r\nExample 1:\r\n\r\nInput: \r\nnums = [3,4,5,6], target = 7\r\n\r\nOutput: [0,1]. Explanation: nums[0] + nums[1] == 7, so we return [0, 1].\r\n\r\n'}, {'Plain Text': 'Use a sliding window with a set to find the length of the longest substring without repeating characters. Expand the window by moving the right pointer and add characters to the set. If a character repeats, move the left pointer to the right until the repeating character is removed from the set. Track and update the maximum length of the substring found.', 'Code': 'class Solution:\r\n    def lengthOfLongestSubstring(self, s: str) -> int:\r\n        charSet = set()\r\n        l = 0\r\n        res = 0\r\n\r\n        for r in range(len(s)):\r\n            while s[r] in charSet:\r\n                charSet.remove(s[l])\r\n                l += 1\r\n            charSet.add(s[r])\r\n            res = max(res, r - l + 1)\r\n        return res\r\n', 'Question': 'Given a string s, find the length of the longest substring without duplicate characters.\r\n\r\nA substring is a contiguous sequence of characters within a string.\r\n\r\nExample 1:\r\n\r\nInput: s = "zxyzxyz"\r\n\r\nOutput: 3\r\nExplanation: The string "xyz" is the longest without duplicate characters.'}, {'Plain Text': 'Use binary search to find the target in a sorted list. Initialize pointers at the start and end of the list. Calculate the middle index and compare the middle element with the target. Adjust the pointers based on whether the middle element is greater or lesser than the target. Repeat until the target is found or the search space is exhausted. Return the index of the target or -1 if it is not found.', 'Code': 'class Solution:\r\n    def search(self, nums: List[int], target: int) -> int:\r\n        l, r = 0, len(nums) - 1\r\n\r\n        while l <= r:\r\n            m = l + ((r - l) // 2)  # (l + r) // 2 can lead to overflow\r\n            if nums[m] > target:\r\n                r = m - 1\r\n            elif nums[m] < target:\r\n                l = m + 1\r\n            else:\r\n                return m\r\n        return -1\r\n', 'Question': 'You are given an array of distinct integers nums, sorted in ascending order, and an integer target.\r\n\r\nImplement a function to search for target within nums. If it exists, then return its index, otherwise, return -1.\r\n\r\nYour solution must run in \r\nð‘‚(ð‘™ð‘œð‘”ð‘›) time.\r\n\r\nExample 1:\r\n\r\nInput: nums = [-1,0,2,4,6,8], target = 4\r\n\r\nOutput: 3'}, {'Plain Text': "Reverse a singly linked list by iterating through it. Maintain pointers for the previous and current nodes, updating each node's next pointer to point to the previous node as you traverse the list. Return the new head of the reversed list after the traversal is complete.\r\n\r\n\r\n\r\n\r\n\r\n", 'Code': 'class Solution:\r\n    def reverseList(self, head: ListNode) -> ListNode:\r\n        prev, curr = None, head\r\n\r\n        while curr:\r\n            temp = curr.next\r\n            curr.next = prev\r\n            prev = curr\r\n            curr = temp\r\n        return prev', 'Question': 'Given the beginning of a singly linked list head, reverse the list, and return the new beginning of the list.\r\n\r\nExample 1:\r\n\r\nInput: head = [0,1,2,3]\r\n\r\nOutput: [3,2,1,0]'}, {'Plain Text': "To remove the nth node from the end of a linked list, first create a dummy node to handle edge cases. Move the right pointer n steps ahead. Then, move both left and right pointers together until the right pointer reaches the end of the list. Finally, adjust the next pointer of the left node to remove the target node, and return the list starting from the dummy's next node.", 'Code': 'class Solution:\r\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\r\n        dummy = ListNode(0, head)\r\n        left = dummy\r\n        right = head\r\n\r\n        while n > 0:\r\n            right = right.next\r\n            n -= 1\r\n\r\n        while right:\r\n            left = left.next\r\n            right = right.next\r\n\r\n        left.next = left.next.next\r\n        return dummy.next', 'Question': 'You are given the beginning of a linked list head, and an integer n.\r\n\r\nRemove the nth node from the end of the list and return the beginning of the list.\r\n\r\nExample 1:\r\n\r\nInput: head = [1,2,3,4], n = 2\r\n\r\nOutput: [1,2,4]\r\nExample 2:\r\n\r\nInput: head = [5], n = 1\r\n\r\nOutput: []\r\nExample 3:\r\n\r\nInput: head = [1,2], n = 2\r\n\r\nOutput: [2]\r\nConstraints:\r\n\r\nThe number of nodes in the list is sz.\r\n1 <= sz <= 30\r\n0 <= Node.val <= 100\r\n1 <= n <= sz'}, {'Plain Text': "To search for a target in a rotated sorted array, use a binary search approach. Initialize two pointers, l and r, at the start and end of the array. Calculate the midpoint and compare it with the target. Adjust the pointers based on the sorted portion of the array and the target's position relative to mid. Continue until the target is found or the pointers converge, and return the index or -1 if the target is not found", 'Code': 'class Solution:\r\n    def search(self, nums: List[int], target: int) -> int:\r\n        l, r = 0, len(nums) - 1\r\n\r\n        while l <= r:\r\n            mid = (l + r) // 2\r\n            if target == nums[mid]:\r\n                return mid\r\n\r\n            if nums[l] <= nums[mid]:\r\n                if target > nums[mid] or target < nums[l]:\r\n                    l = mid + 1\r\n                else:\r\n                    r = mid - 1\r\n                    \r\n            else:\r\n                if target < nums[mid] or target > nums[r]:\r\n                    r = mid - 1\r\n                else:\r\n                    l = mid + 1\r\n        return -1\r\n', 'Question': 'You are given an array of length n which was originally sorted in ascending order. It has now been rotated between 1 and n times. For example, the array nums = [1,2,3,4,5,6] might become:\r\n\r\n[3,4,5,6,1,2] if it was rotated 4 times.\r\n[1,2,3,4,5,6] if it was rotated 6 times.\r\nGiven the rotated sorted array nums and an integer target, return the index of target within nums, or -1 if it is not present.\r\n\r\nYou may assume all elements in the sorted rotated array nums are unique,\r\n\r\nA solution that runs in O(n) time is trivial, can you write an algorithm that runs in O(log n) time?\r\n\r\nExample 1:\r\n\r\nInput: nums = [3,4,5,6,1,2], target = 1\r\n\r\nOutput: 4\r\n\r\nExample 2:\r\n\r\nInput: nums = [3,5,6,0,1,2], target = 4\r\n\r\nOutput: -1\r\n\r\nConstraints:\r\n\r\n1 <= nums.length <= 1000\r\n-1000 <= nums[i] <= 1000\r\n-1000 <= target <= 1000'}, {'Plain Text': "To check if s1's permutation is a substring of s2, first compare their lengths and return False if s1 is longer. Count character frequencies for s1 and the initial window of s2. Track matches of character frequencies. Slide the window across s2, updating counts and matches. If matches reach 26, return True. Adjust the left and right ends of the window, updating matches accordingly. Finally, return True if a permutation match is found, otherwise return False.", 'Code': 'class Solution:\r\n    def checkInclusion(self, s1: str, s2: str) -> bool:\r\n        if len(s1) > len(s2):\r\n            return False\r\n\r\n        s1Count, s2Count = [0] * 26, [0] * 26\r\n        for i in range(len(s1)):\r\n            s1Count[ord(s1[i]) - ord("a")] += 1\r\n            s2Count[ord(s2[i]) - ord("a")] += 1\r\n\r\n        matches = 0\r\n        for i in range(26):\r\n            matches += 1 if s1Count[i] == s2Count[i] else 0\r\n\r\n        l = 0\r\n        for r in range(len(s1), len(s2)):\r\n            if matches == 26:\r\n                return True\r\n\r\n            index = ord(s2[r]) - ord("a")\r\n            s2Count[index] += 1\r\n            if s1Count[index] == s2Count[index]:\r\n                matches += 1\r\n            elif s1Count[index] + 1 == s2Count[index]:\r\n                matches -= 1\r\n\r\n            index = ord(s2[l]) - ord("a")\r\n            s2Count[index] -= 1\r\n            if s1Count[index] == s2Count[index]:\r\n                matches += 1\r\n            elif s1Count[index] - 1 == s2Count[index]:\r\n                matches -= 1\r\n            l += 1\r\n        return matches == 26\r\n', 'Question': 'You are given two strings s1 and s2.\r\n\r\nReturn true if s2 contains a permutation of s1, or false otherwise. That means if a permutation of s1 exists as a substring of s2, then return true.\r\n\r\nBoth strings only contain lowercase letters.\r\n\r\nExample 1:\r\n\r\nInput: s1 = "abc", s2 = "lecabee"\r\n\r\nOutput: true\r\nExplanation: The substring "cab" is a permutation of "abc" and is present in "lecabee".\r\n\r\nExample 2:\r\n\r\nInput: s1 = "abc", s2 = "lecaabee"\r\n\r\nOutput: false\r\nConstraints:\r\n\r\n1 <= s1.length, s2.length <= 1000'}, {'Plain Text': '\r\nTo move all zeros in the list to the end while maintaining the order of non-zero elements, use a two-pointer technique. Initialize slow at the start. Iterate through the list with fast. When a non-zero element at fast is found and the element at slow is zero, swap them. Increment slow when it points to a non-zero element. This shifts all zeros to the end in a single pass.', 'Code': 'class Solution:\r\n    def moveZeroes(self, nums: list) -> None:\r\n        slow = 0\r\n        for fast in range(len(nums)):\r\n            if nums[fast] != 0 and nums[slow] == 0:\r\n                nums[slow], nums[fast] = nums[fast], nums[slow]\r\n\r\n            if nums[slow] != 0:\r\n                slow += 1', 'Question': "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.\r\n\r\nNote that you must do this in-place without making a copy of the array.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [0,1,0,3,12]\r\nOutput: [1,3,12,0,0]\r\nExample 2:\r\n\r\nInput: nums = [0]\r\nOutput: [0]\r\n \r\n\r\nConstraints:\r\n\r\n1 <= nums.length <= 10^4\r\n-2^31 <= nums[i] <= 2^31 - 1"}, {'Plain Text': "To determine the sign of the product of an array's elements without calculating the actual product, initialize a variable product_sign to 1. Iterate through the array, and for each element, return 0 if it's zero. If an element is negative, flip the sign of product_sign. Finally, return 1 if product_sign is positive and -1 if it is negative. This approach ensures that only the sign of the product is considered, not its magnitude.", 'Code': 'class Solution:\r\n    def arraySign(self, nums: List[int]) -> int:\r\n        product_sign = 1\r\n\r\n        for num in nums:\r\n            if num == 0:\r\n                return 0\r\n            if num < 0:\r\n                product_sign *= -1\r\n\r\n        if product_sign > 0:\r\n            return 1\r\n        else:\r\n            return -1', 'Question': 'There is a function signFunc(x) that returns:\r\n\r\n1 if x is positive.\r\n-1 if x is negative.\r\n0 if x is equal to 0.\r\nYou are given an integer array nums. Let product be the product of all values in the array nums.\r\n\r\nReturn signFunc(product).\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [-1,-2,-3,-4,3,2,1]\r\nOutput: 1\r\nExplanation: The product of all values in the array is 144, and signFunc(144) = 1\r\nExample 2:\r\n\r\nInput: nums = [1,5,0,2,-3]\r\nOutput: 0\r\nExplanation: The product of all values in the array is 0, and signFunc(0) = 0\r\nExample 3:\r\n\r\nInput: nums = [-1,1,-1,1,-1]\r\nOutput: -1\r\nExplanation: The product of all values in the array is -1, and signFunc(-1) = -1\r\n \r\n\r\nConstraints:\r\n\r\n1 <= nums.length <= 1000\r\n-100 <= nums[i] <= 100\r\n'}, {'Plain Text': 'Iterate through the string, converting uppercase letters to lowercase and removing non-alphanumeric characters. For each alphanumeric character encountered, append it to a new string. After completing the traversal, compare the new string with its reverse. If they match, the original string is a palindrome, so return true; otherwise, return false.', 'Code': "class Solution:\r\n    def isPalindrome(self, s: str) -> bool:\r\n        new = ''\r\n        for a in s:\r\n            if a.isalpha() or a.isdigit():\r\n                new += a.lower()\r\n        return (new == new[::-1])\r\n", 'Question': 'A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\r\n\r\nGiven a string s, return true if it is a palindrome, or false otherwise.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: s = "A man, a plan, a canal: Panama"\r\nOutput: true\r\nExplanation: "amanaplanacanalpanama" is a palindrome.'}, {'Plain Text': 'Leveraging string concatenation for sorting and comparison. Go through  the given list of non-negative integers, converting each integer to its string representation. Sort the list of strings based on their  concatenated representations to determine their relative order. Ensure proper handling for the case where all numbers in the list are zeroes. Concatenate the sorted strings and return the result as a string.', 'Code': "class Solution:\r\n    def largestNumber(self, nums: List[int]) -> str:\r\n        # Convert integers to strings\r\n        nums = [str(num) for num in nums]\r\n\r\n        # Custom sort based on concatenated string representations\r\n        nums.sort(key=lambda x: x*10, reverse=True)\r\n\r\n        # Handle case where all numbers are 0\r\n        if nums[0] == '0':\r\n            return '0'\r\n\r\n        # Concatenate sorted strings and return\r\n        return ''.join(nums)", 'Question': 'Given a list of non-negative integers nums, arrange them such that they form the largest number and return it.\r\n\r\nSince the result may be very large, so you need to return a string instead of an integer.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [10,2]\r\nOutput: "210"'}, {'Plain Text': 'Using two-pointer approach for merging sorted arrays. Initialize pointers a, b, and write_index. Iterate backwards through nums1 and nums2 simultaneously, comparing elements pointed to by a and b, and filling in nums1 from the end. Ensure proper handling for elements in nums2 that are not yet merged.', 'Code': 'class Solution:    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:        a, b, write_index = m-1, n-1, m + n - 1\r\n        while b >= 0:            if a >= 0 and nums1[a] > nums2[b]:                nums1[write_index] = nums1[a]                a -= 1            else:                nums1[write_index] = nums2[b]                b -= 1\r\n            write_index -= 1', 'Question': 'You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\r\n\r\nMerge nums1 and nums2 into a single array sorted in non-decreasing order.\r\n\r\nThe final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.\r\n\r\n\xa0\r\nExample 1:\r\n\r\nInput: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\r\nOutput: [1,2,2,3,5,6]\r\nExplanation: The arrays we are merging are [1,2,3] and [2,5,6].\r\nThe result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.'}, {'Plain Text': 'Using sliding window approach to find the maximum frequency of an element after performing at most k operations. Sort the array nums. Initialize pointers left, right, and variables ans and curr. Iterate through nums using a sliding window defined by left and right. Increment curr by the value at right in each iteration. While the cost of converting the window into a uniform array exceeds k, decrement curr by the value at left and increment left. Update ans with the maximum length of the valid window encountered. Return ans as the maximum possible frequency of an element.', 'Code': 'class Solution:\r\n    def maxFrequency(self, nums: List[int], k: int) -> int:\r\n        nums.sort()\r\n        left = 0\r\n        ans = 0\r\n        curr = 0\r\n        \r\n        for right in range(len(nums)):\r\n            target = nums[right]\r\n            curr += target\r\n            \r\n            while (right - left + 1) * target - curr > k:\r\n                curr -= nums[left]\r\n                left += 1\r\n            \r\n            ans = max(ans, right - left + 1)\r\n\r\n        return ans', 'Question': 'The frequency of an element is the number of times it occurs in an array.\r\n\r\nYou are given an integer array nums and an integer k. In one operation, you can choose an index of nums and increment the element at that index by 1.\r\n\r\nReturn the maximum possible frequency of an element after performing at most k operations.\r\n\r\nExample 2:\r\n\r\nInput: nums = [1,4,8,13], k = 5\r\nOutput: 2\r\nExplanation: There are multiple optimal solutions:\r\n- Increment the first element three times to make nums = [4,4,8,13]. 4 has a frequency of 2.\r\n- Increment the second element four times to make nums = [1,8,8,13]. 8 has a frequency of 2.\r\n- Increment the third element five times to make nums = [1,4,13,13]. 13 has a frequency of 2.'}, {'Plain Text': 'Utilizing a stack to track indices of temperatures and calculate the number of days until warmer temperatures. Initialize an array res to store the result with zeros. Create an empty stack to store pairs [temperature, index]. Iterate through the temperatures, keeping track of both the temperature and its index. While the stack is not empty and the current temperature is greater than the temperature at the top of the stack, pop elements from the stack, calculate the number of days until warmer temperatures for the popped indices, and update res accordingly. Push the current temperature and its index onto the stack. Finally, return res containing the number of days until warmer temperatures for each temperature in the input array.', 'Code': 'class Solution:\r\n    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:\r\n        res = [0] * len(temperatures)\r\n        stack = []  # pair: [temp, index]\r\n\r\n        for i, t in enumerate(temperatures):\r\n            while stack and t > stack[-1][0]:\r\n                stackT, stackInd = stack.pop()\r\n                res[stackInd] = i - stackInd\r\n            stack.append((t, i))\r\n        return res', 'Question': 'You are given an array of integers temperatures where temperatures[i] represents the daily temperatures on the ith day.\r\nReturn an array result where result[i] is the number of days after the ith\r\n day before a warmer temperature appears on a future day. If there is no\r\n day in the future where a warmer temperature will appear for the ith day, set result[i] to 0 instead.\r\nExample 1:\r\nInput: temperatures = [30,38,30,36,35,40,28]\r\n\r\nOutput: [1,4,1,2,1,0,0]'}, {'Plain Text': 'This code uses binary search to find the single element that appears only once in a sorted array. It compares elements at midpoints and their adjacent elements. By adjusting the search range based on these comparisons, it identifies the unique element efficiently. This approach ensures O(log n) time complexity and O(1) space complexity.', 'Code': 'class Solution:\r\n    def singleNonDuplicate(self, nums: List[int]) -> int:\r\n        left, right = 0, len(nums) - 1\r\n        while left < right:\r\n            mid = (left + right) // 2\r\n            if mid % 2 == 1:\r\n                mid -= 1\r\n            if nums[mid] != nums[mid + 1]:\r\n                right = mid\r\n            else:\r\n                left = mid + 2\r\n        return nums[left]', 'Question': 'You are given a sorted array consisting of only integers where every \r\nelement appears exactly twice, except for one element which appears \r\nexactly once.\r\n\r\nReturn the single element that appears only once.\r\n\r\nYour solution must run in O(log n) time and O(1) space.\r\n\r\n\xa0\r\nExample 1:\r\nInput: nums = [1,1,2,3,3,4,4,8,8]\r\nOutput: 2'}, {'Plain Text': 'This code finds the middle node of a singly linked list using a two-pointer approach. It initializes two pointers, slow and fast, both starting at the head of the linked list. While the fast pointer and its next node are not None, it advances the slow pointer by one node and the fast pointer by two nodes. This effectively makes the slow pointer reach the middle node when the fast pointer reaches the end. Finally, it returns the slow pointer, which points to the middle (or second middle) node of the linked list.', 'Code': 'class Solution:\r\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        slow = head\r\n        fast = head\r\n        while(fast and fast.next):\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n        \r\n        return slow', 'Question': 'Given the head of a singly linked list, return the middle node of the linked list.\r\n\r\nIf there are two middle nodes, return the second middle node.\r\n\r\n\xa0\r\nExample 1:\r\nInput: head = [1,2,3,4,5,6]\r\nOutput: [4,5,6]\r\nExplanation: Since the list has two middle nodes with values 3 and 4, we return the second one.'}, {'Plain Text': 'Iterate through the array of stock prices, keep track of the lowest price seen so far. Calculate the potential profit for each subsequent day by subtracting the lowest price from the current price. Update the maximum profit seen so far if the potential profit is greater. Return the maximum profit achieved.', 'Code': 'class Solution:\r\n    def maxProfit(self, prices: List[int]) -> int:\r\n        res = 0\r\n        \r\n        lowest = prices[0]\r\n        for price in prices:\r\n            if price < lowest:\r\n                lowest = price\r\n            res = max(res, price - lowest)\r\n        return res\r\n', 'Question': 'You are given an array prices where prices[i] is the price of a given stock on the ith day.\r\n\r\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\r\n\r\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: prices = [7,1,5,3,6,4]\r\nOutput: 5\r\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\r\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.'}, {'Plain Text': "Use a stack to keep track of opening brackets. As we go through the string, push opening brackets onto the stack and pop them off when we encounter their corresponding closing brackets. If the stack is empty at the end, the string is valid; otherwise, it's not.", 'Code': 'class Solution:\r\n    def isValid(self, s: str) -> bool:\r\n        Map = {")": "(", "]": "[", "}": "{"}\r\n        stack = []\r\n\r\n        for c in s:\r\n            if c not in Map:\r\n                stack.append(c)\r\n                continue\r\n            if not stack or stack[-1] != Map[c]:\r\n                return False\r\n            stack.pop()\r\n\r\n        return not stack\r\n', 'Question': 'Given a string s containing just the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\', determine if the input string is valid.\r\n\r\nAn input string is valid if:\r\n\r\nOpen brackets must be closed by the same type of brackets.\r\nOpen brackets must be closed in the correct order.\r\nEvery close bracket has a corresponding open bracket of the same type.\r\n \r\n\r\nExample 1:\r\n\r\nInput: s = "()"\r\nOutput: true\r\nExample 2:\r\n\r\nInput: s = "()[]{}"\r\nOutput: true'}, {'Plain Text': 'To group anagrams from a list of strings, create a defaultdict of lists. For each string, generate a character count tuple representing the frequency of each letter. Use this tuple as the key to group anagrams together. The result is a list of grouped anagrams.', 'Code': 'class Solution:\r\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\r\n        ans = defaultdict(list)\r\n\r\n        for s in strs:\r\n            count = [0] * 26\r\n            for c in s:\r\n                count[ord(c) - ord("a")] += 1\r\n            ans[tuple(count)].append(s)\r\n        return ans.values()\r\n', 'Question': 'Given an array of strings\xa0strs, group all\xa0anagrams\xa0together into sublists. You may return the output in\xa0any order.\r\nAn\xa0anagram\xa0is a string that contains the exact same characters as another string, but the order of the characters can be different.\r\n\r\nExample : 1\r\nInput: strs = ["act","pots","tops","cat","stop","hat"]\r\nOutput: [["hat"],["act", "cat"],["stop", "pots", "tops"]]\r\n'}, {'Plain Text': 'To find all unique triplets in an array that sum to zero, sort the array first. Iterate through the array, using two pointers (left and right) to find pairs that sum to the negative of the current element. Skip duplicate elements to avoid repeating triplets. The result is a list of these unique triplets.', 'Code': 'class Solution:\r\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\r\n        res = []\r\n        nums.sort()\r\n\r\n        for i, a in enumerate(nums):\r\n            if a > 0:\r\n                break\r\n\r\n            if i > 0 and a == nums[i - 1]:\r\n                continue\r\n\r\n            l, r = i + 1, len(nums) - 1\r\n            while l < r:\r\n                threeSum = a + nums[l] + nums[r]\r\n                if threeSum > 0:\r\n                    r -= 1\r\n                elif threeSum < 0:\r\n                    l += 1\r\n                else:\r\n                    res.append([a, nums[l], nums[r]])\r\n                    l += 1\r\n                    r -= 1\r\n                    while nums[l] == nums[l - 1] and l < r:\r\n                        l += 1\r\n                        \r\n        return res\r\n', 'Question': 'Given an integer array\xa0nums, return all the triplets\xa0[nums[i], nums[j], nums[k]]\xa0where\xa0nums[i] + nums[j] + nums[k] == 0, and the indices\xa0i,\xa0j\xa0and\xa0k\xa0are all distinct.\r\nThe output should\xa0not\xa0contain any duplicate triplets. You may return the output and the triplets in\xa0any order.\r\nExample 1:\r\nInput: nums = [-1,0,1,2,-1,-4]\r\n\r\nOutput: [[-1,-1,2],[-1,0,1]]'}, {'Plain Text': 'To find the length of the longest substring with at most `k` replacements, use a sliding window approach. Maintain a count of characters in the current window and track the maximum frequency of any character. If the window size minus the max frequency exceeds `k`, shrink the window from the left. The result is the maximum length of such a substring.', 'Code': 'class Solution:\r\n    def characterReplacement(self, s: str, k: int) -> int:\r\n        count = {}\r\n        \r\n        l = 0\r\n        maxf = 0\r\n        for r in range(len(s)):\r\n            count[s[r]] = 1 + count.get(s[r], 0)\r\n            maxf = max(maxf, count[s[r]])\r\n\r\n            if (r - l + 1) - maxf > k:\r\n                count[s[l]] -= 1\r\n                l += 1\r\n\r\n        return (r - l + 1)\r\n', 'Question': '\r\nYou are given a string\xa0s\xa0consisting of only uppercase english characters and an integer\xa0k. You can choose up to\xa0k\xa0characters of the string and replace them with any other uppercase English character.\r\nAfter performing at most\xa0k\xa0replacements, return the length of the longest substring which contains only one distinct character.\r\nExample 1:\r\nInput: s = "XYYX", k = 2\r\nOutput: 4\r\n'}, {'Plain Text': 'To find the minimum eating rate `k` to finish all banana piles within `h` hours, use binary search between 1 and the maximum pile size. For each mid-point `k`, calculate the total hours needed to eat all bananas. If the total hours are within `h`, adjust the search range to find a smaller `k`; otherwise, increase `k`. The result is the minimum `k` that allows eating all bananas within `h` hours.', 'Code': 'class Solution:\r\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\r\n        l, r = 1, max(piles)\r\n        res = r\r\n\r\n        while l <= r:\r\n            k = (l + r) // 2\r\n\r\n            totalTime = 0\r\n            for p in piles:\r\n                totalTime += math.ceil(float(p) / k)\r\n            if totalTime <= h:\r\n                res = k\r\n                r = k - 1\r\n            else:\r\n                l = k + 1\r\n        return res\r\n', 'Question': 'You are given an integer array piles where piles[i] is the number of bananas in the ith pile. You are also given an integer h, which represents the number of hours you have to eat all the bananas.\r\n\r\nYou may decide your bananas-per-hour eating rate of k. Each hour, you may choose a pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, you may finish eating the pile but you can not eat from another pile in the same hour.\r\n\r\nReturn the minimum integer k such that you can eat all the bananas within h hours.\r\n\r\nExample 1:\r\n\r\nInput: piles = [1,4,3,2], h = 9\r\n\r\nOutput: 2'}, {'Plain Text': 'To reorder a singly linked list in the specified pattern, first use the slow and fast pointer technique to find the middle of the list. Reverse the second half of the list. Then, merge the two halves by alternating nodes from each half. This rearranges the nodes in the required order without modifying their values.', 'Code': 'class Solution:\r\n    def reorderList(self, head: Optional[ListNode]) -> None:\r\n        slow, fast = head, head.next\r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n\r\n        second = slow.next\r\n        prev = slow.next = None\r\n        while second:\r\n            tmp = second.next\r\n            second.next = prev\r\n            prev = second\r\n            second = tmp\r\n\r\n        first, second = head, prev\r\n        while second:\r\n            tmp1, tmp2 = first.next, second.next\r\n            first.next = second\r\n            second.next = tmp1\r\n            first, second = tmp1, tmp2\r\n', 'Question': "You are given the head of a singly linked-list.\r\n\r\nThe positions of a linked list of length = 7 for example, can intially be represented as:\r\n\r\n[0, 1, 2, 3, 4, 5, 6]\r\n\r\nReorder the nodes of the linked list to be in the following order:\r\n\r\n[0, 6, 1, 5, 2, 4, 3]\r\n\r\nNotice that in the general case for a list of length = n the nodes are reordered to be in the following order:\r\n\r\n[0, n-1, 1, n-2, 2, n-3, ...]\r\n\r\nYou may not modify the values in the list's nodes, but instead you must reorder the nodes themselves.\r\n\r\nExample 1:\r\n\r\nInput: head = [2,4,6,8]\r\n\r\nOutput: [2,8,4,6]"}]
[2024-06-06T22:38:16.033+0000] {taskinstance.py:441} INFO - ::group::Post task execution logs
[2024-06-06T22:38:16.116+0000] {taskinstance.py:1206} INFO - Marking task as SUCCESS. dag_id=data_pipeline_v2, task_id=load_data, run_id=manual__2024-06-06T22:38:10.830526+00:00, execution_date=20240606T223810, start_date=20240606T223814, end_date=20240606T223816
[2024-06-06T22:38:16.195+0000] {local_task_job_runner.py:240} INFO - Task exited with return code 0
[2024-06-06T22:38:16.279+0000] {taskinstance.py:3498} INFO - 0 downstream tasks scheduled from follow-on schedule check
[2024-06-06T22:38:16.287+0000] {local_task_job_runner.py:222} INFO - ::endgroup::
